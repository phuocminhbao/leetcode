/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
const solve = (board) => {
    const X = "X";
    const O = "O";
    const UNSURROUNDED_REGIONS = new Set();
    const bfs = (row, col) => {
        if (UNSURROUNDED_REGIONS.has(`${row}-${col}`)) {
            return;
        }
        UNSURROUNDED_REGIONS.add(`${row}-${col}`);
        const queue = [[row, col]];
        while (queue.length > 0) {
            const [currRow, currCol] = queue.shift();
            [
                [0, 1],
                [1, 0],
                [0, -1],
                [-1, 0],
            ].forEach(([addtionalRow, addtionalcol]) => {
                const [nextRow, nextCol] = [
                    currRow + addtionalRow,
                    currCol + addtionalcol,
                ];
                const nextCell = board[nextRow]?.[nextCol] ?? X;
                if (
                    UNSURROUNDED_REGIONS.has(`${nextRow}-${nextCol}`) ||
                    nextCell === X
                ) {
                    return;
                }
                queue.push([nextRow, nextCol]);
                UNSURROUNDED_REGIONS.add(`${nextRow}-${nextCol}`);
            });
        }
    };
    const dfs = (row, col) => {
        if (
            board[row]?.[col] !== O ||
            UNSURROUNDED_REGIONS.has(`${row}-${col}`)
        ) {
            return;
        }
        UNSURROUNDED_REGIONS.add(`${row}-${col}`);
        dfs(row, col + 1);
        dfs(row + 1, col);
        dfs(row, col - 1);
        dfs(row - 1, col);
    };
    const [FIRST_ROW, LAST_ROW, FIRST_COL, LAST_COL] = [
        0,
        board.length - 1,
        0,
        board[0].length - 1,
    ];
    [FIRST_ROW, LAST_ROW].forEach((row) => {
        for (let col = 0; col <= LAST_COL; col++) {
            const cell = board[row][col];
            if (cell === O) {
                dfs(row, col);
            }
        }
    });
    [FIRST_COL, LAST_COL].forEach((col) => {
        for (let row = 0; row <= LAST_ROW; row++) {
            const cell = board[row][col];
            dfs(row, col);
        }
    });
    for (let row = 0; row <= LAST_ROW; row++) {
        for (let col = 0; col <= LAST_COL; col++) {
            if (
                board[row][col] === O &&
                !UNSURROUNDED_REGIONS.has(`${row}-${col}`)
            ) {
                board[row][col] = X;
            }
        }
    }
    debugger;
};

const board = [
    [
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
    ],
    [
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "X",
    ],
    [
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
    ],
    [
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
    ],
    [
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "X",
    ],
    [
        "X",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "X",
        "O",
        "X",
        "O",
        "X",
        "O",
        "X",
        "O",
    ],
    [
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
    ],
    [
        "X",
        "O",
        "O",
        "O",
        "X",
        "X",
        "X",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "X",
        "X",
        "O",
        "X",
        "O",
        "O",
        "O",
    ],
    [
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "X",
        "X",
        "X",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
    ],
    [
        "X",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "X",
        "O",
        "O",
        "X",
        "O",
        "O",
        "X",
    ],
    [
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "X",
        "O",
        "X",
    ],
    [
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "X",
        "O",
        "O",
        "X",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
    ],
    [
        "X",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
    ],
    [
        "O",
        "X",
        "O",
        "X",
        "O",
        "O",
        "O",
        "X",
        "O",
        "X",
        "O",
        "O",
        "O",
        "X",
        "O",
        "X",
        "O",
        "X",
        "O",
        "O",
    ],
    [
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "X",
        "O",
    ],
    [
        "X",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "X",
        "X",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
    ],
    [
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "X",
        "O",
        "X",
        "O",
        "X",
        "O",
        "O",
    ],
    [
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "O",
        "O",
        "X",
        "X",
        "X",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "X",
        "O",
    ],
    [
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
        "O",
    ],
    [
        "X",
        "O",
        "O",
        "O",
        "O",
        "X",
        "O",
        "O",
        "O",
        "X",
        "X",
        "O",
        "O",
        "X",
        "O",
        "X",
        "O",
        "X",
        "O",
        "O",
    ],
];
solve(board);
debugger;
